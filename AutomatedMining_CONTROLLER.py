#! /usr/bin/env python
#
# GUI module generated by PAGE version 4.9
# In conjunction with Tcl version 8.6
#    Feb 26, 2018 12:01:25 PM

"""
{Description}
Manual Mining Functions
"""

__author__ = ["Candy Espulgar"]
__copyright__ = "Copyright 2019 - TE3D House, Copyright 2020 - Liverpool Hope University"
__credits__ = ["Arnulfo Azcarraga, Neil Buckley"]
__version__ = "3.0"

'''
    This class handles all functionality for AutomatedMining_View.
    [Candy]
'''

import tkMessageBox
import copy

import Tkinter as tk

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk

    py3 = 0
except ImportError:
    import tkinter.ttk as ttk

    py3 = 1

import Tkinter
import math
import collections
import Color_support as CS
import Icon_support
import UI_support
import PIL.Image
import PIL.ImageTk
import CONSTANTS as const
import Function_support as FS
import __Loader_support as LS
import UIConstants_support as UICS


class AutomatedMining_Controller:

    def __init__(self, view, model, root):

        self.view = view
        self.model = model
        self.root = root
        self.dictWidgetPlace = {}
        self.dict_result_data = None  # To be initialized by loadSourceFolder()
        self.list_feature_codes = None
        self.list_feature_codes_original = None
        self.prev_selection_feature_codes = 0
        self.prev_selection_feature_groups = 0
        self.dict_Significant_DTPairs = None
        self.list_selected_features = None  # Initialized by addFeature() (Or the function for Check #1)
        self.dict_selected_features = None  # The basis for Feature Groups (a.k.a Listbox # 2)

        self.list_selected_feature_groups = None  # Contains all dataset pairs for the selected significant features
        self.list_feature_groups = None
        self.list_str_feature_groups = None
        self.RESULT_LEFT = "L"
        self.RESULT_RIGHT = "R"
        self.dataset_pair_left = None
        self.dataset_pair_right = None

        self.configureTestTabBindings()
        self.initializeVariables()

        self.disableListResultTable()

    def setArrQueryCriticalValue(self, arrayValue):
        self.arrQueryCriticalValue = arrayValue

    def setArrQueryCriticalValueMapping(self, arrayValue):
        self.arrQueryCriticalValueMapping = arrayValue

    def initializeVariables(self):
        # Selected UI for MM
        self.selectOptionChangeCrossType(None)  # This selects the default algorithm in MM
        self.showConsoleScreen(None, self.listConsoleScreen)  # Click ALL type

        # Button state variables (This is used instead of directly disabling buttons to keep their appearance)
        self.buttonQueryFeature_state = DISABLED

        self.hasUploadedVariableDescription = False
        self.hasUploadedPopulation = False

        self.isReadyDatasetA = False
        self.isReadyDatasetB = False
        # self.checkIfDatasetReady()
        self.resetDatasetContents()


    def resetDatasetContents(self):
        # self.populationDataset = []
        self.populationDatasetOriginalA = {'Data': [], 'Filter Features': []}
        self.populationDatasetOriginalB = {'Data': [], 'Filter Features': []}
        self.datasetA = {'Data': [], 'Filter Features': []}
        self.datasetB = {'Data': [], 'Filter Features': []}

        global tests_gl
        tests_gl = []
        self.datasetCountA = len(self.datasetA['Data'])
        self.datasetCountB = len(self.datasetB['Data'])
        self.lblSelectedFeatureCount.configure(text = str(0))
        self.lblSelectedGroupCount.configure(text = self.getDatasetCountB())

        # self.queryResetDatasetA(None)
        # self.queryResetDatasetB(None)

    def readFeatures(self, variableDescription, itemMarker):
        global features_gl
        features_gl = FS.readFeatures(variableDescription, itemMarker)
        if (len(features_gl)) <= 0:  # Invalid variable description file
            return False
        else:
            return True

    '''
    Upload the dataset specified by the given path.

    '''

    def uploadDataset(self, directory, newDataset):
        global populationDir_gl
        populationDir_gl = directory

        self.populationDataset = newDataset

        # Reset contents of dataset variables
        self.resetDatasetContents()

        for record in self.populationDataset:
            self.datasetA['Data'].append(record)
            self.datasetB['Data'].append(record)
            self.populationDatasetOriginalA['Data'].append(record)  # This keeps a copy of the unaltered dataset
            self.populationDatasetOriginalB['Data'].append(record)  # This keeps a copy of the unaltered dataset

        # TODO Show the total samples of the unaltered dataset
        # self.datasetCountA = len(self.datasetA['Data'])
        # self.datasetCountB = len(self.datasetB['Data'])
        self.datasetCountA = 0
        self.datasetCountB = 0

        self.labelQueryDataACount.configure(text = self.getDatasetCountA())
        self.lblSelectedGroupCount.configure(text = self.getDatasetCountB())

        print "UPLOADED"
        return True

    def defocusLeft(self, event):
        self.dropQueryLeft.master.focus_set()

    def defocusRight(self, event):
        self.dropQueryRight.master.focus_set()

    def configureTestTabBindings(self):

        # GENERAL
        self.dictConsoleScreens = self.view.getDictConsoleScreens()

        # LABEL FRAMES
        self.labelOverlayFilterListData = self.view.getLabelOverlayFilterListData()
        self.labelFrameFilterListData = self.view.getLabelFrameFilterListData()
        self.lblResultTableStripes = self.view.getLblFilterResultStripes()
        self.lblStatusSourceFolder = self.view.getLblStatusSourceFolder()
        self.labelQuerySetDataStatusB = self.view.getLabelQuerySetDataStatusB()
        self.lblStripesFeatureCodes = self.view.getLblStripesFeatureCodes()
        self.lblStripeFeatureGroups = self.view.getLblStripesFeatureGroups()

        # LABELS
        self.lblLeftResultFocusValue = self.view.getLblLeftResultFocusValue()  # The BOTTOM label for the result table
        self.lblRightResultFocusValue = self.view.getRightResultFocusValue()

        self.labelQueryDataFeatureName = self.view.getLabelQueryDataFeatureName()
        self.listResultsLeft = self.view.getListResultsLeft()
        self.listResultsRight = self.view.getListResultsRight()

        # self.labelQueueCount = self.view.getLabelQueueCount()
        self.labelConsoleScreenTaskBar = self.view.getLabelConsoleScreenTaskBar()

        self.lblSelectedFeatureCount = self.view.getLblSelectedFeatureCount()
        self.lblSelectedGroupCount = self.view.getLblSelectedGroupCount()

        # LISTBOXES
        self.listFeatureCodes = self.view.getListFeatureCodes()
        self.listFeatureGroups = self.view.getListFeatureGroups()

        # SPINBOXES
        self.spinBoxChangeLevel = self.view.getSpinBoxChangeLevel()
        self.spinBoxChangeCrossType = self.view.getSpinBoxChangeCrossType()

        # COMBOBOXES
        self.dropQueryLeft = self.view.getDropQueryLeft()
        self.dropQueryLeft.bind('<<ComboboxSelected>>', self.dropDownLeft)

        self.dropQueryRight = self.view.getDropQueryRight()
        self.dropQueryRight.bind('<<ComboboxSelected>>', self.dropDownRight)

        self.dropQueryLeft.bind("<FocusIn>", self.defocusLeft)
        self.dropQueryRight.bind("<FocusIn>", self.defocusRight)

        # ENTRIES
        self.entryQueryLeft = self.view.getEntryQueryLeft()
        self.entryQueryRight = self.view.getEntryQueryRight()
        self.entrySourceFolderFilename = self.view.getEntrySourceFolderFilename()
        self.entryQuerySetDataB = self.view.getEntryQuerySetDataB()

        # BUTTONS

        self.labelFrameProcessChangeLevel = self.view.getLabelFrameProcessChangeLevel()
        self.labelFrameProcessChangeCrossType = self.view.getLabelFrameProcessChangeCrossType()

        self.btnLoadSource = self.view.getBtnLoadSource()
        self.btnLoadSource.bind('<Button-1>', self.loadSourceFolder)  # TODO When find is pressed, find pickle file


        # The Check button in the first box
        self.btnAddFeatureCode = self.view.getBtnAddFeatureCode()  # When arrow is pressed in first list box
        self.btnAddFeatureCode.bind('<Button-1>', self.addFeatureCode)

        self.listResultsLeft = self.view.getListResultsLeft()
        self.btnSearchResultsLeft = self.view.getBtnSearchResultsLeft()  # When arrow is pressed in left result
        self.btnSearchResultsLeft.bind('<Button-1>', self.triggerLeftResults)

        self.btnListResultsRight = self.view.getListResultsRight()  # When arrow is pressed in right result
        self.btnSearchResultsRight = self.view.getBtnSearchResultsRight()  # When arrow is pressed in left result
        self.btnSearchResultsRight.bind('<Button-1>', self.triggerRightResults)

        self.applyCrossTypeSpinbox = self.view.getButtonApplyCrossTypeSpinBox()
        self.applyCrossTypeSpinbox.bind('<Button-1>', self.applyCrossType)

        self.applyCrossLevelSpinbox = self.view.getButtonApplyLevelSpinBox()
        self.applyCrossLevelSpinbox.bind('<Button-1>', self.applyCrossLevel)


        # The Check button in the second box (AKA Apply filters)
        # self.btnApplySelectedFeatureSearch = self.view.getButtonQueryAddFilterB()
        # self.btnApplySelectedFeatureSearch.bind('<Button-1>', self.queryAddFilterB)

        self.btnCompareSelectedFeatureGroups = self.view.getBtnCompareSelectedFeatureGroups()
        self.btnCompareSelectedFeatureGroups.bind('<Button-1>', self.compareSelectedFeatureGroups)
        # self.buttonQueryFeature.configure(command = self.querySetFeature)
        # self.buttonQueryFeatureA.bind('<Button-1>', self.querySetFeatureA)
        # self.buttonQueryFeatureB.bind('<Button-1>', self.querySetFeatureB)


        # self.buttonQueue = self.view.getButtonQueue()
        # self.buttonQueue.bind('<Button-1>', self.queue)  # Enqueue Subset-pairs

        # self.buttonClearQueue = self.view.getButtonClearQueue()
        # self.buttonClearQueue.bind('<Button-1>', self.clearQueue)

        self.buttonTestQueue = self.view.getButtonRunAutomatedMiner()
        self.buttonTestQueue.bind('<Button-1>', self.runAutomatedMiner)  # Run Miner Button

        self.buttonQueryResetFilterA = self.view.getButtonQueryResetFilterA()
        self.buttonQueryResetFilterA.bind('<Button-1>', self.resetSelectedFeatureCodes)

        self.buttonQueryResetFilterB = self.view.getButtonQueryResetFilterB()
        self.buttonQueryResetFilterB.bind('<Button-1>', self.resetSelectedFeatureGroups)

        # Test option buttons
        self.buttonChooseChiSquare = self.view.getButtonChooseChiSquare()
        self.buttonChooseChiSquare.bind('<Button-1>', self.selectOptionChangeCrossType)

        self.buttonChooseZTest = self.view.getButtonChooseZTest()
        self.buttonChooseZTest.bind('<Button-1>', self.selectOptionChangeLevel)

        # Console buttons
        self.buttonConsoleAll = self.view.getButtonConsoleAll()
        self.buttonConsoleAll.bind("<Button-1>", lambda event: self.showConsoleScreen(event, self.listConsoleScreen))

        self.buttonConsoleZTest = self.view.getButtonConsoleZTest()
        self.buttonConsoleZTest.bind("<Button-1>",
                                     lambda event: self.showConsoleScreen(event, self.listConsoleZTestScreen))

        self.buttonConsoleChiSquare = self.view.getButtonConsoleChiSquare()
        self.buttonConsoleChiSquare.bind("<Button-1>",
                                         lambda event: self.showConsoleScreen(event, self.listConsoleChiSquareScreen))

        self.buttonConsoleQueue = self.view.getButtonConsoleQueue()
        self.buttonConsoleQueue.bind("<Button-1>",
                                     lambda event: self.showConsoleScreen(event, self.listConsoleQueueScreen))
        # self.buttonConsoleAll.bind('<Button-1>', self.showConsoleScreen(self.listConsoleScreen))
        # self.buttonConsoleZTest.bind('<Button-1>', self.showConsoleScreen(self.listConsoleZTestScreen))
        # self.buttonConsoleChiSquare.bind('<Button-1>', self.showConsoleScreen(self.listConsoleChiSquareScreen))
        # self.buttonConsoleQueue.bind('<Button-1>', self.showConsoleScreen(self.listConsoleQueueScreen))

        # FOCUS IN / OUT

        self.listConsoleScreen = self.view.getListConsoleScreen()
        self.listConsoleScreen.bind("<ButtonRelease>",
                                    lambda event: self.selectConsoleEntry(event, self.listConsoleScreen))

        self.listConsoleZTestScreen = self.view.getListConsoleZTestScreen()
        self.listConsoleZTestScreen.bind("<ButtonRelease>",
                                         lambda event: self.selectConsoleEntry(event, self.listConsoleZTestScreen))

        self.listConsoleChiSquareScreen = self.view.getListConsoleChiSquareScreen()
        self.listConsoleChiSquareScreen.bind("<ButtonRelease>", lambda event: self.selectConsoleEntry(event,
                                                                                                      self.listConsoleChiSquareScreen))

        self.listConsoleQueueScreen = self.view.getListConsoleQueueScreen()
        self.listConsoleQueueScreen.bind("<ButtonRelease>",
                                         lambda event: self.selectConsoleEntry(event, self.listConsoleQueueScreen))

        # ENTER / LEAVE
        self.btnLoadSource.bind("<Enter>", self.enterRightArrowPlainIcon)
        self.btnLoadSource.bind("<Leave>", self.leaveRightArrowPlainIcon)


        self.btnSearchResultsLeft.bind("<Enter>", self.enterDownArrowPlainIcon)
        self.btnSearchResultsLeft.bind("<Leave>", self.leaveDownArrowPlainIcon)

        self.btnSearchResultsRight.bind("<Enter>", self.enterDownArrowPlainIcon)
        self.btnSearchResultsRight.bind("<Leave>", self.leaveDownArrowPlainIcon)
        # self.buttonQuerySetDataB.bind("<Enter>", lambda event, iconSize =  Icon_support.SELECT_ICO_SIZE_BUTTONS: self.enterRightArrowIcon(event, Icon_support.SELECT_ICO_SIZE_BUTTONS))
        # self.buttonQuerySetDataB.bind("<Leave>", self.leaveRightArrowIcon(Icon_support.SELECT_ICO_SIZE_BUTTONS))

        self.btnAddFeatureCode.bind("<Enter>", self.enterCheckIcon)
        self.btnAddFeatureCode.bind("<Leave>", self.leaveCheckIcon)

        self.btnCompareSelectedFeatureGroups.bind("<Enter>", self.enterCheckIcon)
        self.btnCompareSelectedFeatureGroups.bind("<Leave>", self.leaveCheckIcon)


        self.applyCrossTypeSpinbox.bind("<Enter>", self.enterCheckIcon)
        self.applyCrossTypeSpinbox.bind("<Leave>", self.leaveCheckIcon)

        self.buttonTestQueue.bind("<Enter>", self.enterRightArrowIcon)
        self.buttonTestQueue.bind("<Leave>", self.leaveRightArrowIcon)

        self.buttonQueryResetFilterA.bind("<Enter>", self.enterCrossIcon)
        self.buttonQueryResetFilterA.bind("<Leave>", self.leaveCrossIcon)

        self.buttonQueryResetFilterB.bind("<Enter>", self.enterCrossIcon)
        self.buttonQueryResetFilterB.bind("<Leave>", self.leaveCrossIcon)

        # LISTBOX
        self.listFeatureCodes = self.view.getListFeatureCodes()
        self.listFeatureCodes.bind('<<ListboxSelect>>', self.querySelectedFeatureCodes)
        self.listFeatureGroups = self.view.getListFeatureGroups()
        self.listFeatureGroups.bind('<<ListboxSelect>>', self.querySelectedFeatureGroups)

        self.listResultsLeft = self.view.getListResultsLeft()
        self.listResultsLeft.bind('<<ListboxSelect>>', self.setLeftResultFocusValue)
        self.listResultsRight = self.view.getListResultsRight()
        self.listResultsRight.bind('<<ListboxSelect>>', self.setRightResultFocusValue)


    ''' --> Elements under the TEST ("TEST") TAB (2) <-- '''
    # region

    '''SELECT HEADER'''
    def applyCrossType(self, event):
        new_cross = self.spinBoxChangeCrossType.get()
        UICS.MAX_CROSS = new_cross
        tkMessageBox.showinfo("CROSS TYPE Successfully Changed", "The new CROSS TYPE is now " + str(UICS.MAX_CROSS))
        return "break"

    def applyCrossLevel(self, event):
        new_level = self.spinBoxChangeLevel.get()
        UICS.MAX_LEVEL = new_level
        tkMessageBox.showinfo("CROSS LEVEL Successfully Changed", "The new LEVEL is now " + str(UICS.MAX_LEVEL))
        return "break"

    def dropDownLeft(self, event):
        self.dropQueryLeft.selection_clear()

        self.dataset_pair_left = str(event.widget.get()).strip()

        if self.dataset_pair_left is not None:
            self.addToResultTable(self.RESULT_LEFT, self.dataset_pair_left)


    def dropDownRight(self, event):
        self.dropQueryRight.selection_clear()

        self.dataset_pair_right = str(event.widget.get()).strip()

        if self.dataset_pair_right is not None:
            self.addToResultTable(self.RESULT_RIGHT, self.dataset_pair_right)


    ''' Load existing Pickle file '''

    def loadSourceFolder(self, evt):
        print("Loading Source Folder : loadSourceFolder()")
        willLoad = True
        if self.list_feature_codes is not None:
            message_box = tkMessageBox.askquestion("Overwrite Session", "Loading a new pickle will overwrite your current session. Proceed?", icon = "warning")
            if message_box == 'yes':
                willLoad = True
            else:
                willLoad = False
            # else:
            #     tk.tkMessageBox.showinfo('Return', 'You will now return to the application screen')

        if willLoad:
            entry_source_folder_filename = self.entrySourceFolderFilename.get()
            filename = entry_source_folder_filename.strip()  # Directory name now
            # print(filename)

            # If entry box is empty, the program assumes the default directory
            if len(filename) <= 0:
                filename = str("\\" + LS.GL_AM_EXCEL_FOLDER_NAME)

            if LS.checkExcelFileExistence(filename):
                self.list_feature_codes = []  # Reset feature codes when making a new pickle
                self.list_feature_codes_original = []

                self.dict_results = LS.loadCSVResultDictionary()  # Loads all excel files from the specified directory
                self.result_colnames = LS.RESULT_COLNAMES
                self.addToListFeatureCode(self.dict_results)
            else:
                tkMessageBox.showerror("Error: File not found",
                                       "Please place UI Result.csv files in | _output/" + self.entrySourceFolderFilename.get() + "/ | and try again.")


        return "break"


    '''
        Extract all single features available in the result dictionary.
        Append all unique features to Feature Codes Listbox.
    '''
    def addToListFeatureCode(self, dict_results):
        # Create a dictionary where the chosen SSFs are the keys
        # Colnames contain ["Feature", "DoF", "P Value", "Chi Square", "Observed", "Expected", "IsSignificant"]
        self.dict_Significant_DTPairs = collections.OrderedDict()
        self.dict_DTPairs_ResultTable = dict_results

        # print("")
        # print("Features read from source folder")
        # print("")
        # print df_results
        for key_DTPair, result_table in dict_results.items():
            feature_codes = result_table[self.result_colnames[0]]  # Returns the array of significant features
            # print(key_DTPair)
            # print(feature_codes)
            # print("")
            feature_codes = sorted(feature_codes)  # Sort feature codes
            # print(feature_codes)
            # Update list of feature codes
            for feature_code in feature_codes:  # Parse that array and check if each single feature has been recorded
                if feature_code not in self.list_feature_codes:
                    self.list_feature_codes.append(feature_code)  # This is the list that's parsed to update the listbox

                # Then update the dictionary of significant_features : dataset pairs (the key here)
                if feature_code not in self.dict_Significant_DTPairs:
                    self.dict_Significant_DTPairs[feature_code] = []  # If the feature_code/key does not exist in the dictionary, add it with an empty list

                self.dict_Significant_DTPairs[feature_code].append(key_DTPair)

        self.list_feature_codes.sort()  # Sort
        self.list_feature_codes_original = copy.deepcopy(self.list_feature_codes)  # Create an untouched copy

        # print(self.dict_Significant_DTPairs)

        # Remove previous listbox entries from all other listboxes
        self.clearAllFeatureListsBoxes(None)

        # Add the new features to the listbox (listFeatureCodes)
        for i_feature_code in range(len(self.list_feature_codes)):
            feature_code = self.list_feature_codes[i_feature_code]

            index = i_feature_code + 1
            str_index = str(index)
            if index < 10:
                str_index = "  " + str_index
            elif index < 100:
                str_index = " " + str_index
            str_entry = UICS.PRE_LIST + str_index + "| " + feature_code
            self.listFeatureCodes.insert(END, str_entry)
        # return list_features


    def resetSelectedFeatureCodes(self, evt):
        # Reset stripe
        self.setStripeReady(False, self.lblStripesFeatureCodes)

        # Deselect all selected items/indices
        selected = self.listFeatureCodes.curselection()
        for index in selected[::-1]:
            self.listFeatureCodes.selection_clear(index)

        # Reset selected count label
        selection_count = len(self.listFeatureCodes.curselection())
        self.lblSelectedFeatureCount.configure(text = str(selection_count))

        self.clearAllFeatureGroups(None)
        self.clearAllResultTables(None)
        # print("CROSS 1")
        return "break"

    def resetSelectedFeatureGroups(self, evt):
        # Reset stripe
        self.setStripeReady(False, self.lblStripeFeatureGroups)
        self.disableListResultTable()  # Close result table

        # Deselect all selected items/indices
        selected = self.listFeatureGroups.curselection()
        for index in selected[::-1]:
            self.listFeatureGroups.selection_clear(index)

        # Reset selected count label
        selection_count = len(self.listFeatureGroups.curselection())
        self.lblSelectedGroupCount.configure(text = str(selection_count))

        self.clearAllResultTables(None)
        # print("CROSS 2")
        return "break"

    def clearAllFeatureListsBoxes(self, evt):
        self.clearAllFeatureCodes(None)
        self.clearAllFeatureGroups(None)
        self.clearAllResultTables(None)

    def clearAllFeatureCodes(self, evt):
        # Reset stripe
        self.setStripeReady(False, self.lblStripesFeatureCodes)

        # Clear connected variables
        self.list_selected_features = []

        # Delete all contents
        self.listFeatureCodes.delete(0, END)
        self.dict_selected_features = collections.OrderedDict()

        # Reset selected count zero
        self.lblSelectedFeatureCount.configure(text = str(0))


    def clearAllFeatureGroups(self, evt):
        # Reset stripe
        self.setStripeReady(False, self.lblStripeFeatureGroups)

        # Clear all connected variables
        self.list_selected_feature_groups = []

        # Delete all contents
        self.listFeatureGroups.delete(0, END)

        # Reset selected count zero
        self.lblSelectedGroupCount.configure(text = str(0))

    def clearAllResultTables(self, evt):
        # Reset stripe
        self.setStripeReady(False, self.lblResultTableStripes, False)

        # Clear all connected variables
        self.list_str_feature_groups = []
        self.dataset_pair_left = None
        self.dataset_pair_right = None

        # Reset bottom status to NO DATA
        self.lblLeftResultFocusValue.configure(text = str("NO DATA"))  # NO DATA
        self.lblRightResultFocusValue.configure(text = str("NO DATA"))  # NO DATA

        # Remove Contents
        self.listResultsLeft.delete(0, END)
        self.listResultsRight.delete(0, END)

        self.dropQueryLeft.config(values = self.list_str_feature_groups)  # Removes drop down contents
        self.dropQueryLeft.delete(0, END)
        self.dropQueryLeft.set('')

        self.dropQueryRight.config(values = self.list_str_feature_groups)
        self.dropQueryRight.delete(0, END)
        self.dropQueryRight.set('')

        # LOCK result table
        self.disableListResultTable()

    def querySelectedFeatureCodes(self, evt):  # TODO List box function 1

        # Update Selection Count
        selection_count = len(self.listFeatureCodes.curselection())

        self.lblSelectedFeatureCount.configure(text = str(selection_count))
        if selection_count != self.prev_selection_feature_codes:
            self.setStripeReady(False, self.lblStripesFeatureCodes)  # Change stripe color
            self.clearAllFeatureGroups(None)  # Clear other tables whenever user changes selection
            self.clearAllResultTables(None)
        self.prev_selection_feature_codes = selection_count

        # print("ON LIST SELECT 1")


    def querySelectedFeatureGroups(self, evt):  # TODO List box function 2
        # Update Selection Count
        selection_count = len(self.listFeatureGroups.curselection())

        self.lblSelectedGroupCount.configure(text = str(selection_count))
        if selection_count != self.prev_selection_feature_groups:
            self.setStripeReady(False, self.lblStripeFeatureGroups)  # Change stripe color
            self.clearAllResultTables(None)  # Clear other tables whenever user changes selection
        self.prev_selection_feature_groups = selection_count
        # print("ON LIST SELECT 2")


    '''
        Sets the Chi-square and P Value at the bottom of the table.
        Also shows the DoF and Cut-off.
    '''
    def setLeftResultFocusValue(self, event):
        # Update BOTTOM LABEL

        self.setStripeReady(False, self.lblResultTableStripes, False)  # Change stripe color

        i_selected = self.listResultsLeft.curselection()[0]

        if i_selected > 0:
            i_selected = i_selected - 1
            str_drop_down_item = self.dropQueryLeft.get().strip()  # The currently selected item in the drop down

            # [0 "Feature", 1 "DoF", 2 "P Value", 3 "Chi Square", 4 "Observed", 5 "Expected", 6 "IsSignificant"]
            str_left_result_details = "Chi-Value: "
            chi_value = self.dict_DTPairs_ResultTable[str_drop_down_item]['Chi Square'][i_selected]
            chi_value = round(float(chi_value), 2)
            str_left_result_details = str_left_result_details + str(chi_value) + " | "

            str_left_result_details = str_left_result_details + "P-Value: "
            p_value = self.dict_DTPairs_ResultTable[str_drop_down_item]['P Value'][i_selected]
            p_value = round(float(p_value), 4)
            str_left_result_details = str_left_result_details + str(p_value) + " | "

            str_left_result_details = str_left_result_details + "DoF: "
            dof = self.dict_DTPairs_ResultTable[str_drop_down_item]['DoF'][i_selected]
            dof = round(float(dof), 2)
            str_left_result_details = str_left_result_details + str(dof)

            self.lblLeftResultFocusValue.config(text = str_left_result_details)
        else:
            self.lblLeftResultFocusValue.config(text = "")

    def setRightResultFocusValue(self, event):
        # Update BOTTOM LABEL
        self.setStripeReady(False, self.lblResultTableStripes, False)  # Change stripe color

        i_selected = self.listResultsRight.curselection()[0]

        if i_selected > 0:
            i_selected = i_selected - 1
            str_drop_down_item = self.dropQueryRight.get().strip()  # The currently selected item in the drop down

            # [0 "Feature", 1 "DoF", 2 "P Value", 3 "Chi Square", 4 "Observed", 5 "Expected", 6 "IsSignificant"]
            str_right_result_details = "Chi-Value: "
            chi_value = self.dict_DTPairs_ResultTable[str_drop_down_item]['Chi Square'][i_selected]
            chi_value = round(float(chi_value), 2)
            str_right_result_details = str_right_result_details + str(chi_value) + " | "

            str_right_result_details = str_right_result_details + "P-Value: "
            p_value = self.dict_DTPairs_ResultTable[str_drop_down_item]['P Value'][i_selected]
            p_value = round(float(p_value), 4)
            str_right_result_details = str_right_result_details + str(p_value) + " | "

            str_right_result_details = str_right_result_details + "DoF: "
            dof = self.dict_DTPairs_ResultTable[str_drop_down_item]['DoF'][i_selected]
            dof = round(float(dof), 2)
            str_right_result_details = str_right_result_details + str(dof)

            self.lblRightResultFocusValue.config(text = str_right_result_details)
            
        else:
            self.lblRightResultFocusValue.config(text = "")


    # endregion


    '''FILTER HEADER'''
    # region

    ''' Simultaneously scrolls the FILTER listbox A and B'''

    # def scrollFilterListBox(self, evt):  # To simultaneously scroll Filter listbox A and B
    #     self.listResultsLeft.yview("scroll", evt.delta, "units")
    #     self.listResultsRight.yview("scroll", evt.delta, "units")
    #     # this prevents default bindings from firing, which
    #     # would end up scrolling the widget twice
    #     return "break"

    def addFeatureCode(self, evt):
        # Search in Dictionary

        list_selectedFeatureCodes = self.listFeatureCodes.curselection()  # Right statement returns indices
        len_selected_features = len(list_selectedFeatureCodes)
        if len_selected_features > 0:
            self.setStripeReady(True, self.lblStripesFeatureCodes)  # Change stripe color to indicate input accepted

            self.list_selected_features = []
            list_selectedFeatureCodes = sorted(list_selectedFeatureCodes)

            for index in list_selectedFeatureCodes:  # Loop through each selected index
                str_list_box_entry = self.listFeatureCodes.get(index)
                # The pipe (|) is the delimiter between the number (which is lfc index + 1) and feature code (e.g. 1| a3)
                str_entry = [x.strip() for x in str_list_box_entry.split('|')]  # Use strip to remove spaces
                lfc_index = int(str_entry[0]) - 1  # The real list index starts at 0
                feat_code = self.list_feature_codes[lfc_index]  # Equivalent to str_entry[1]

                # list_inclusive_DTPairs = self.dict_Significant_DTPairs[feat_code]
                self.list_selected_features.append(feat_code)

            self.list_selected_features.sort()
            # print(""
            #       ""
            #       "")
            # print self.list_selected_features
            self.dict_selected_features = collections.OrderedDict()
            for feature in self.list_selected_features:
                self.dict_selected_features[feature] = self.dict_Significant_DTPairs[feature]

            # self.dict_selected_features = collections.OrderedDict({k: self.dict_Significant_DTPairs[k] for k in (self.list_selected_features)})

            # print(self.dict_selected_features)
            self.updateFeatureGroupList()
        # print("CHECK 1")
        return "break"


    '''
        Update Feature Group List (Listbox #2) with the values of the dictionary.
        Write the parent feature code (instead of the integer) on the left side of the
        pipe (|).
    '''
    def updateFeatureGroupList(self):
        self.listFeatureGroups.delete(0, END)  # Empty the listbox before adding
        self.list_selected_feature_groups = []

        shortenText = False
        list_entries = []
        i_longest_length = 0
        for feat_code, dt_pairs in self.dict_selected_features.items():
            len_feat_code = len(feat_code)
            if len_feat_code < 3:  # Add a space before the feature code if its length is less than 3
                feat_code = " " + feat_code

            str_entry_index = feat_code + "|"
            for dt_pair in dt_pairs:
                str_entry = str_entry_index + dt_pair
                len_entry = len(str_entry)

                if len_entry > 33:  # If length of text is longer than box, shorten later
                    shortenText = True
                    if len_entry > i_longest_length:
                        i_longest_length = len_entry

                list_entries.append(str_entry)
                print (dt_pairs)
                self.list_selected_feature_groups.append(dt_pairs)  # Contains all dataset pairs for the selected significant features

        for entry in list_entries:
            if shortenText:  # Shorten the entries as required
                entry = entry[1:]
                entry = entry.replace(" VS ", "|")

            self.listFeatureGroups.insert(END, entry)






    def compareSelectedFeatureGroups(self, evt):
        list_selectedFeatureGroups = self.listFeatureGroups.curselection()  # Right statement returns indices
        len_selected_groups = len(list_selectedFeatureGroups)
        if len_selected_groups > 0:  # If selection is not empty
            self.setStripeReady(True, self.lblStripeFeatureGroups)  # Change stripe color to indicate input accepted
            self.enableListResultTable()  # Show result table if input is accepted

            self.list_feature_groups = []
            self.list_str_feature_groups = []
            for index in list_selectedFeatureGroups:
                str_list_box_entry = self.listFeatureGroups.get(index)

                # The pipe (|) is the delimiter between the feature code and dataset pair/group
                str_list_box_entry = str_list_box_entry.replace("|", "?", 1)
                str_list_box_entry = str_list_box_entry.replace("|", " VS ")
                str_list_box_entry = str_list_box_entry.replace("?", "|")
                # print(str_list_box_entry)

                str_entry = [x.strip() for x in str_list_box_entry.split('|')]  # Use strip to remove spaces
                feat_code = str_entry[0]
                dataset_pair = str_entry[1]  # Returns the "x(n) VS y(m)" notation of the dataset pair

                self.list_feature_groups.append(dataset_pair)  # This will contain the list of dataset pairs to show
                self.list_str_feature_groups.append(" " + str(dataset_pair))

        self.dropQueryLeft.config(values = self.list_str_feature_groups)
        self.dropQueryRight.config(values = self.list_str_feature_groups)


        # if event:
        #     print('event.widget.get():', event.widget.get())

        # self.addToResultTable()
        # print("CHECK 2")
        return "break"

    def triggerLeftResults(self, event):
        # print("TRIGGER LEFT RESULTS")
        self.dropQueryLeft.event_generate('<Button-1>')
        self.dropQueryLeft.selection_clear()

        return "break"

    def triggerRightResults(self, event):
        # print("TRIGGER RIGHT RESULTS")
        self.dropQueryRight.event_generate('<Button-1>')

        if self.dataset_pair_right is not None:
            dataset_pair = self.entryQueryRight.get()
            self.dataset_pair_right = dataset_pair
            self.addToResultTable(self.RESULT_RIGHT, self.dataset_pair_right)

        return "break"


    '''
        Add the details of the selected dataset pair to their corresponding result table.
        This function adds 1 set of details to the specified table in parameter 2.
    '''
    def addToResultTable(self, table_code, dataset_pair):

        if table_code is self.RESULT_LEFT:
            self.listResultsLeft.delete(0, END)

        elif table_code is self.RESULT_RIGHT:
            self.listResultsRight.delete(0, END)

        result_table = self.dict_DTPairs_ResultTable[dataset_pair]

        col_features = result_table['Feature']  # [0 "Feature", 2 "DoF", 3 "P Value", 4 "Chi Square", 5 "Observed", 6 "Expected", 7 "IsSignificant"]
        col_pval = result_table['P Value']
        col_observed = result_table['Observed']
        col_expected = result_table['Expected']
        len_columns = len(col_features)
        separator = "|"

        # Print column names
        entry = "  FC " + separator + \
                "D1:a" + separator + "D1:b" + separator + "D2:a" + separator + "D2:b" + separator + \
                "E1:a" + separator + "E1:b" + separator + "E2:a" + separator + "E2:b"

        if table_code is self.RESULT_LEFT:
            self.listResultsLeft.insert(END, entry)

        elif table_code is self.RESULT_RIGHT:
            self.listResultsRight.insert(END, entry)


        for i in range(len_columns):
            entry = ""

            feat_code = col_features[i].strip()
            len_feat_code = len(feat_code)
            if len_feat_code < 3:
                feat_code = " " + feat_code

            entry = entry + " " + feat_code + " " + separator

            # pval = str(col_pval[i])
            # len_pval = len(pval)
            # if len_pval < 8:
            #     difference = 8 - len_pval
            #     pval = pval + " " * difference
            #
            # entry = entry + str(pval) + separator

            observed = ""
            raw_col_observed = col_observed[i]
            raw_col_observed = raw_col_observed.split(';')
            for str_item in raw_col_observed:
                str_item = str_item.strip()
                str_item = str_item.replace("[", "").strip()
                str_item = str_item.replace("]", "").strip()
                single_items = str_item.split(" ")

                single_items = filter(None, single_items)
                for str_single in single_items:

                    str_single = str_single.strip()
                    len_str_single = len(str_single)
                    if len_str_single < 4:
                        difference = 4 - len_str_single
                        str_single = str_single + " " * difference
                    observed = observed + str_single + separator

            entry = entry + observed


            # entry = entry + col_expected[i]
            expected = ""
            raw_col_expected = col_expected[i]
            raw_col_expected = raw_col_expected.split(';')
            for str_item in raw_col_expected:
                str_item = str_item.strip()
                str_item = str_item.replace("[", "").strip()
                str_item = str_item.replace("]", "").strip()
                single_items = str_item.split(" ")

                single_items = filter(None, single_items)
                for str_single in single_items:

                    str_single = str_single.strip()
                    i_single = float(str_single)
                    str_single = str(math.trunc(i_single))

                    len_str_single = len(str_single)
                    if len_str_single < 4:
                        difference = 4 - len_str_single
                        str_single = str_single + " " * difference
                    expected = expected + str_single + separator

            entry = entry + expected

            if table_code is self.RESULT_LEFT:
                self.listResultsLeft.insert(END, entry)

            elif table_code is self.RESULT_RIGHT:
                self.listResultsRight.insert(END, entry)


    '''TEST HEADER'''

    # region

    def selectOptionChangeCrossType(self, evt):

        # Change button appearance to selected
        self.buttonChooseChiSquare.configure(
            background = CS.PROCESS_CHI_SQUARE_TITLE_FG,
            foreground = CS.PROCESS_CHI_SQUARE_TITLE_BG
        )

        # Revert other buttons to deselected
        self.buttonChooseZTest.configure(
            background = CS.PROCESS_Z_TEST_TITLE_BG,
            foreground = CS.PROCESS_Z_TEST_TITLE_FG,
        )

        self.hideWidget(self.labelFrameProcessChangeLevel)
        self.showWidget(self.labelFrameProcessChangeCrossType)

    def selectOptionChangeLevel(self, evt):
        # Change button appearance to selected
        self.buttonChooseZTest.configure(
            background = CS.PROCESS_CHI_SQUARE_TITLE_FG,
            foreground = CS.PROCESS_CHI_SQUARE_TITLE_BG
        )
        # Revert other buttons to deselected
        self.buttonChooseChiSquare.configure(
            background = CS.PROCESS_Z_TEST_TITLE_BG,
            foreground = CS.PROCESS_Z_TEST_TITLE_FG,
        )

        self.hideWidget(self.labelFrameProcessChangeCrossType)
        self.showWidget(self.labelFrameProcessChangeLevel)

    ''' Adds test to the queue '''

    def addToQueue(self, testType, **params):
        global tests_gl
        test = {'Type': testType}
        for key in params:
            if (key == 'popDirArg'):
                test['Population Path'] = copy.copy(params[key])
            elif (key == 'sampleFeatArg'):
                test['Sample Feature'] = copy.copy(params[key])
            elif (key == 'selectedFeatArg'):
                test['Selected Feature'] = copy.copy(params[key])
            elif (key == 'allValArg'):
                test['SF All Values'] = copy.copy(params[key])
            elif (key == 'selValArg'):
                test['SF Selected Values'] = copy.copy(params[key])
            elif (key == 'datasetArgs'):
                test['Datasets'] = copy.deepcopy(params[key])
            elif (key == 'zArg'):
                test['Z Critical Value'] = copy.copy(params[key])
        tests_gl.append(test)
        self.labelQueueCount.configure(text = str(len(tests_gl)))
        tkMessageBox.showinfo("Test queued", test['Type'] + " has been queued.")

        '''
        self.buttonInitialVarDesc.configure(
            background=CS.DATASET_BTN_BG, foreground=CS.DATASET_BTN_FG,
            text=UI_support.BTN_DATASET_UPLOAD,
            bd=1, relief=GROOVE,
            activebackground=CS.DATASET_BTN_BG_ACTIVE, activeforeground=CS.DATASET_BTN_FG_ACTIVE,
            disabledforeground=CS.FG_DISABLED_COLOR)
        '''



    ''' Starts the Automated Mining Process (RUN MINER) '''
    def runAutomatedMiner(self, evt):
        # Launches the SF Thread (pop-up window)
        self.runSystematicFilteringWindow(self.root)
        return "break"



    '''CONSOLE HEADER'''
    # region

    def clearConsole(self):
        self.listConsoleScreen.delete(0, END)

    def addToConsole(self, consoleItem, consoleScreen):
        if self.dictConsoleScreens[consoleScreen] == const.SCREENS.Z_TEST:
            targetScreen = self.listConsoleZTestScreen

        elif self.dictConsoleScreens[consoleScreen] == const.SCREENS.CHI_SQUARE:
            targetScreen = self.listConsoleChiSquareScreen

        elif self.dictConsoleScreens[consoleScreen] == const.SCREENS.QUEUE:
            targetScreen = self.listConsoleQueueScreen

        else:
            targetScreen = self.listConsoleScreen

        targetScreen.configure(state = NORMAL)

        targetScreen.insert(END, consoleItem)
        targetScreen.tag_add(const.CONSOLE.DEFAULT, '1.0', END)

        targetScreen.configure(state = DISABLED)

    '''Select a single line in the console screen Text widget'''

    def selectConsoleEntry(self, event, consoleScreen):
        # Enable console
        consoleScreen.configure(state = NORMAL)

        # Clear previous highlights by deleting the old tag
        consoleScreen.tag_delete(const.CONSOLE.SELECT)

        # Reconfigure tag settings
        consoleScreen.tag_configure(const.CONSOLE.SELECT,
                                    background = CS.FUSCHIA,
                                    foreground = CS.WHITE
                                    )

        # Get current insert index
        insertIndex = float(consoleScreen.index(tk.INSERT))

        # Get the highlight index by taking the floor and ceiling of the insert index
        start = math.floor(insertIndex)
        indexStart = str(start)
        end = start + 1
        indexEnd = str(end)
        # print(str(insertIndex))
        # print("S " + str(indexStart))
        # print("E " + str(indexEnd))
        # self.listConsoleScreen.tag_raise("sel")
        # self.listConsoleScreen.tag_bind(CONSTANTS.CONSOLE.SELECT, show_hand_cursor)

        if consoleScreen.get(indexStart, indexEnd).strip() != '':
            # Highlight the range by specifying the tag
            consoleScreen.tag_add(const.CONSOLE.SELECT, indexStart, indexEnd)

        # Disable the entry to prevent editing
        consoleScreen.configure(state = DISABLED)

    def highlightEntry(self, consoleScreen):
        consoleScreen.text.tag_remove("current_line", 1.0, "end")
        consoleScreen.text.tag_add("current_line", "insert linestart", "insert lineend+1c")

    def showConsoleScreen(self, event, consoleScreen):

        # Hide all screens first
        self.hideWidget(self.listConsoleScreen)
        self.hideWidget(self.listConsoleQueueScreen)
        self.hideWidget(self.listConsoleZTestScreen)
        self.hideWidget(self.listConsoleChiSquareScreen)

        # Reset relief
        self.buttonConsoleAll['relief'] = FLAT
        self.buttonConsoleZTest['relief'] = FLAT
        self.buttonConsoleChiSquare['relief'] = FLAT
        self.buttonConsoleQueue['relief'] = FLAT

        # Reset background color
        self.buttonConsoleAll['background'] = CS.WHITE
        self.buttonConsoleZTest['background'] = CS.WHITE
        self.buttonConsoleChiSquare['background'] = CS.WHITE
        self.buttonConsoleQueue['background'] = CS.WHITE

        # Reset foreground color
        self.buttonConsoleAll['foreground'] = CS.FG_COLOR
        self.buttonConsoleZTest['foreground'] = CS.FG_COLOR
        self.buttonConsoleChiSquare['foreground'] = CS.FG_COLOR
        self.buttonConsoleQueue['foreground'] = CS.FG_COLOR

        if self.dictConsoleScreens[consoleScreen] == const.SCREENS.QUEUE:
            self.showWidget(self.listConsoleQueueScreen)
            self.labelConsoleScreenTaskBar['text'] = '''QUEUE'''
            self.buttonConsoleQueue['background'] = CS.FUSCHIA
            self.buttonConsoleQueue['foreground'] = CS.WHITE
            self.buttonConsoleQueue['relief'] = GROOVE

        elif self.dictConsoleScreens[consoleScreen] == const.SCREENS.Z_TEST:
            self.showWidget(self.listConsoleZTestScreen)
            self.labelConsoleScreenTaskBar['text'] = '''Z-TEST'''
            self.buttonConsoleZTest['background'] = CS.FUSCHIA
            self.buttonConsoleZTest['foreground'] = CS.WHITE
            self.buttonConsoleZTest['relief'] = GROOVE


        elif self.dictConsoleScreens[consoleScreen] == const.SCREENS.CHI_SQUARE:
            self.showWidget(self.listConsoleChiSquareScreen)
            self.labelConsoleScreenTaskBar['text'] = '''CHI-SQUARE'''
            self.buttonConsoleChiSquare['background'] = CS.FUSCHIA
            self.buttonConsoleChiSquare['foreground'] = CS.WHITE
            self.buttonConsoleChiSquare['relief'] = GROOVE


        else:
            self.showWidget(self.listConsoleScreen)
            self.labelConsoleScreenTaskBar['text'] = '''ALL'''
            self.buttonConsoleAll['background'] = CS.FUSCHIA
            self.buttonConsoleAll['foreground'] = CS.WHITE
            self.buttonConsoleAll['relief'] = GROOVE

    """ >>> HELPER FUNCTIONS CALLED BY BOUNDED ELEMENTS (e.g. enter, leave) <<< """

    # TODO Optimize (avoid resizing, keep a reference)
    # region
    def enterCheckIcon(self, event, iconSize = Icon_support.SELECT_ICO_SIZE):
        im = PIL.Image.open(Icon_support.TAB_ICO_CHECK_ON).resize(iconSize, PIL.Image.ANTIALIAS)

        btn_check_icon = PIL.ImageTk.PhotoImage(im)
        item = event.widget
        item.configure(
            image = btn_check_icon)
        item.image = btn_check_icon  # < ! > Required to make images appear

    def leaveCheckIcon(self, event, iconSize = Icon_support.SELECT_ICO_SIZE):
        im = PIL.Image.open(Icon_support.TAB_ICO_CHECK).resize(iconSize, PIL.Image.ANTIALIAS)
        btn_check_icon = PIL.ImageTk.PhotoImage(im)
        item = event.widget
        item.configure(
            image = btn_check_icon)
        item.image = btn_check_icon  # < ! > Required to make images appear

    def enterCrossIcon(self, event, iconSize = Icon_support.SELECT_ICO_SIZE):
        im = PIL.Image.open(Icon_support.TAB_ICO_CROSS_ON).resize(iconSize, PIL.Image.ANTIALIAS)

        btn_cross_icon = PIL.ImageTk.PhotoImage(im)
        item = event.widget
        item.configure(
            image = btn_cross_icon)
        item.image = btn_cross_icon  # < ! > Required to make images appear

    def leaveCrossIcon(self, event, iconSize = Icon_support.SELECT_ICO_SIZE):
        im = PIL.Image.open(Icon_support.TAB_ICO_CROSS).resize(iconSize, PIL.Image.ANTIALIAS)
        btn_cross_icon = PIL.ImageTk.PhotoImage(im)
        item = event.widget
        item.configure(
            image = btn_cross_icon)
        item.image = btn_cross_icon  # < ! > Required to make images appear

    def enterAddIcon(self, event, iconSize = Icon_support.SELECT_ICO_SIZE):
        im = PIL.Image.open(Icon_support.TAB_ICO_ADD_ON).resize(iconSize, PIL.Image.ANTIALIAS)

        btn_add_icon = PIL.ImageTk.PhotoImage(im)
        item = event.widget
        item.configure(
            image = btn_add_icon)
        item.image = btn_add_icon  # < ! > Required to make images appear

    def leaveAddIcon(self, event, iconSize = Icon_support.SELECT_ICO_SIZE):
        im = PIL.Image.open(Icon_support.TAB_ICO_ADD).resize(iconSize, PIL.Image.ANTIALIAS)
        btn_add_icon = PIL.ImageTk.PhotoImage(im)
        item = event.widget
        item.configure(
            image = btn_add_icon)
        item.image = btn_add_icon  # < ! > Required to make images appear

    def enterDownArrowIcon(self, event, iconSize = Icon_support.SELECT_ICO_SIZE):
        item = event.widget

        im = PIL.Image.open(Icon_support.TAB_ICO_DOWN_ARROW_ON).resize(iconSize, PIL.Image.ANTIALIAS)

        btn_down_arrow_icon = PIL.ImageTk.PhotoImage(im)
        item.configure(
            image = btn_down_arrow_icon)
        item.image = btn_down_arrow_icon  # < ! > Required to make images appear

    def leaveDownArrowIcon(self, event, iconSize = Icon_support.SELECT_ICO_SIZE):
        im = PIL.Image.open(Icon_support.TAB_ICO_DOWN_ARROW).resize(iconSize, PIL.Image.ANTIALIAS)
        btn_down_arrow_icon = PIL.ImageTk.PhotoImage(im)
        item = event.widget
        item.configure(
            image = btn_down_arrow_icon)
        item.image = btn_down_arrow_icon  # < ! > Required to make images appear

    def enterRightArrowIcon(self, event, iconSize = Icon_support.RUN_ICO_SIZE):
        item = event.widget

        im = PIL.Image.open(Icon_support.TAB_ICO_RIGHT_ARROW_ON).resize(iconSize, PIL.Image.ANTIALIAS)

        btn_right_arrow_icon = PIL.ImageTk.PhotoImage(im)
        item.configure(
            image = btn_right_arrow_icon)
        item.image = btn_right_arrow_icon  # < ! > Required to make images appear

    def leaveRightArrowIcon(self, event, iconSize = Icon_support.RUN_ICO_SIZE):
        im = PIL.Image.open(Icon_support.TAB_ICO_RIGHT_ARROW).resize(iconSize, PIL.Image.ANTIALIAS)
        btn_right_arrow_icon = PIL.ImageTk.PhotoImage(im)
        item = event.widget
        item.configure(
            image = btn_right_arrow_icon)
        item.image = btn_right_arrow_icon  # < ! > Required to make images appear


    def enterDownArrowPlainIcon(self, event, state = NORMAL, iconSize = Icon_support.SELECT_ICO_SIZE_BUTTONS):
        if state != DISABLED:
            item = event.widget
            im = PIL.Image.open(Icon_support.TAB_ICO_DOWN_ARROW_PLAIN_ON).resize(iconSize, PIL.Image.ANTIALIAS)

            btn_down_arrow_icon = PIL.ImageTk.PhotoImage(im)
            item.configure(
                image = btn_down_arrow_icon)
            item.image = btn_down_arrow_icon  # < ! > Required to make images appear

    def leaveDownArrowPlainIcon(self, event, state = NORMAL, iconSize = Icon_support.SELECT_ICO_SIZE_BUTTONS):
        if state != DISABLED:
            item = event.widget
            im = PIL.Image.open(Icon_support.TAB_ICO_DOWN_ARROW_PLAIN).resize(iconSize, PIL.Image.ANTIALIAS)

            btn_down_arrow_icon = PIL.ImageTk.PhotoImage(im)
            item.configure(
                image = btn_down_arrow_icon)
            item.image = btn_down_arrow_icon  # < ! > Required to make images appear

    def enterRightArrowPlainIcon(self, event, state = NORMAL, iconSize = Icon_support.SELECT_ICO_SIZE_BUTTONS):
        if state != DISABLED:
            item = event.widget
            im = PIL.Image.open(Icon_support.TAB_ICO_RIGHT_ARROW_PLAIN_ON).resize(iconSize, PIL.Image.ANTIALIAS)

            btn_right_arrow_icon = PIL.ImageTk.PhotoImage(im)
            item.configure(
                image = btn_right_arrow_icon)
            item.image = btn_right_arrow_icon  # < ! > Required to make images appear

    def leaveRightArrowPlainIcon(self, event, state = NORMAL, iconSize = Icon_support.SELECT_ICO_SIZE_BUTTONS):
        if state != DISABLED:
            item = event.widget
            if item['state'] != DISABLED:
                im = PIL.Image.open(Icon_support.TAB_ICO_RIGHT_ARROW_PLAIN).resize(iconSize, PIL.Image.ANTIALIAS)
                btn_right_arrow_icon = PIL.ImageTk.PhotoImage(im)
                item.configure(
                    image = btn_right_arrow_icon)
                item.image = btn_right_arrow_icon  # < ! > Required to make images appear

    # endregion

    """ >>> GENERAL HELPER FUNCTIONS <<< """

    def checkIfDatasetReady(self):
        if not self.isReadyDatasetA:  # If Dataset A is not ready
            # Clear and disable filter features option
            self.disableListResultTable()
            self.setDatasetStatusReady(False, self.lblStatusSourceFolder, self.lblStripesFeatureCodes)

        if not self.isReadyDatasetB:  # If Dataset B is not ready
            # Clear and disable filter features option
            self.disableListResultTable()
            self.setDatasetStatusReady(False, self.labelQuerySetDataStatusB, self.lblStripeFeatureGroups)

        if self.isReadyDatasetA and self.isReadyDatasetB:  # If both are ready
            # Enable filter feature option
            self.enableListResultTable()

    def disableListResultTable(self):
        # Clear filter results
        event = None

        # Disable entry
        self.entryQueryLeft.configure(
            state = DISABLED
        )
        # Disable button
        self.buttonQueryFeature_state = DISABLED

        # Disable feature name
        self.labelQueryDataFeatureName.configure(
            background = CS.FILTER_LISTBOX_FEATURE_STATUS_BG,
            foreground = CS.FILTER_LISTBOX_FEATURE_STATUS_FG,
            text = UI_support.FILTER_STATUS_NO_FEATURE_TEXT
        )

        # Show lock cover
        self.labelOverlayFilterListData.place(
            relx = UI_support.getRelX(self.labelFrameFilterListData),
            rely = UI_support.getRelY(self.labelFrameFilterListData),
            relwidth = UI_support.getRelW(self.labelFrameFilterListData),
            relheight = UI_support.getRelH(self.labelFrameFilterListData))

        # Change stripe color
        self.setFilterStripeReady(False, self.lblResultTableStripes)

    def enableListResultTable(self):
        # Enable entry
        self.entryQueryLeft.configure(
            state = NORMAL
        )
        # Enable button
        self.buttonQueryFeature_state = NORMAL

        # Enable feature name
        self.labelQueryDataFeatureName.configure(
            background = CS.FILTER_LISTBOX_FEATURE_STATUS_ON_BG,
            foreground = CS.FILTER_LISTBOX_FEATURE_STATUS_ON_FG,
            text = UI_support.FILTER_STATUS_READY_TEXT
        )

        # Hide lock cover
        self.labelOverlayFilterListData.place(
            relx = FS.getRelX(self.labelFrameFilterListData), rely = FS.getRelY(self.labelFrameFilterListData),
            relwidth = 0, relheight = 0)

        # Change stripe color
        self.setFilterStripeReady(False, self.lblResultTableStripes)

    def setDatasetStatusReady(self, isReady, statusWidget, stripeWidget):
        if isReady:
            statusWidget.configure(
                background = CS.SELECT_LISTBOX_STATUS_READY_BG,
                foreground = CS.SELECT_LISTBOX_STATUS_READY_FG,
                relief = GROOVE
            )
        else:
            statusWidget.configure(
                text = "EXPORT SIGNIFICANT DATASETS",
                background = CS.SELECT_LISTBOX_STATUS_BG,
                foreground = CS.SELECT_LISTBOX_STATUS_FG,
                relief = UI_support.SELECT_LISTBOX_RELIEF
            )

    def setStripeReady(self, isReady, stripeWidget, isOrange = True):

        if isReady:
            im = PIL.Image.open(Icon_support.TEXTURE_STRIPE_LIME)
            texture_lime_stripes = PIL.ImageTk.PhotoImage(im)
            stripeWidget.configure(
                image = texture_lime_stripes
            )
            stripeWidget.image = texture_lime_stripes  # < ! > Required to make images appear
        else:
            if isOrange:
                im = PIL.Image.open(Icon_support.TEXTURE_STRIPE_ORANGE)
                texture_orange_stripes = PIL.ImageTk.PhotoImage(im)
                stripeWidget.configure(
                    image = texture_orange_stripes
                )
                stripeWidget.image = texture_orange_stripes
            else:

                im = PIL.Image.open(Icon_support.TEXTURE_STRIPE_PLUM)
                texture_plum_stripes = PIL.ImageTk.PhotoImage(im)
                stripeWidget.configure(
                    image = texture_plum_stripes
                )
                stripeWidget.image = texture_plum_stripes



    def setFilterStripeReady(self, isReady, stripeWidget):
        if isReady:
            im = PIL.Image.open(Icon_support.TEXTURE_STRIPE_LIME)
            texture_lime_stripes = PIL.ImageTk.PhotoImage(im)
            stripeWidget.configure(
                image = texture_lime_stripes
            )
            stripeWidget.image = texture_lime_stripes  # < ! > Required to make images appear
        else:
            im = PIL.Image.open(Icon_support.TEXTURE_STRIPE_PLUM)
            texture_orange_stripes = PIL.ImageTk.PhotoImage(im)
            stripeWidget.configure(
                image = texture_orange_stripes
            )
            stripeWidget.image = texture_orange_stripes

    """
    Hides the widget by setting its relative width and height to 0.
    Use showWidget() to make the widget re-appear.
    Always set the widget's 'name' first.
    """

    def hideWidget(self, widget):
        widget.update()

        # Store widget width and height if it's not in the dictionary
        widgetName = self.getWidgetName(widget)
        if not (widgetName + '_W' in self.dictWidgetPlace):
            self.dictWidgetPlace[widgetName + '_W'] = UI_support.getRelW(widget)
            self.dictWidgetPlace[widgetName + '_H'] = UI_support.getRelH(widget)

        # Set widget width and height to 0
        widget.place(relwidth = 0, relheight = 0)

    def showWidget(self, widget):

        widgetName = self.getWidgetName(widget)

        # Retrieve widget width and height if it's in the dictionary
        if (widgetName + '_W' in self.dictWidgetPlace):
            widgetWidth = self.dictWidgetPlace[widgetName + '_W']
            widgetHeight = self.dictWidgetPlace[widgetName + '_H']

            # Set widget width and height
            widget.place(relwidth = widgetWidth, relheight = widgetHeight)

            # Remove keys from dictionary
            self.dictWidgetPlace.pop(widgetName + '_W', None)
            self.dictWidgetPlace.pop(widgetName + '_H', None)

        widget.update()

    def getWidgetName(self, widget):
        # print("widget name:", str(widget).split(".")[-1])
        return str(widget).split(".")[-1]

    '''
    Clears all of the filters of the dataset and resets the data back to that of
    the uploaded population file. 
    '''

    def resetDataset(self):
        global populationDir_gl
        new_dataset = {'Data': [], 'Filter Features': []}
        try:
            populationDataset = FS.readCSVDict(populationDir_gl)
            for record in populationDataset:
                new_dataset['Data'].append(record)
            return new_dataset
        except:
            new_dataset = {'Data': [], 'Filter Features': []}
            return new_dataset

    def getDatasetCountA(self):
        return str(self.datasetCountA)

    def getDatasetCountB(self):
        return str(self.datasetCountB)

    # endregion

    # def confirmConfirmedFeatures(self, event):
    #     self.model.confirmConfirmedFeatures(self.root)
    #     return "break"

    def runSystematicFilteringWindow(self, root):
        self.model.runSystematicFiltering(self.root)







